#动态代理
和静态代理要做的一样，它的好处就是不用每次有新的被代理类就要修改现有代理类或者扩展新的代理类，用proxy就可以实现对所有对象的代理

动态代理有两个很重要的类，各司其职(符合单一职责原则)：
- proxy          用来创建代理对象
- InvocationHandler        用来写具体的增强行为
所以我们来看用法：
```java
        ManFactory o = (ManFactory)Proxy.newProxyInstance(AFactory.class.getClassLoader(),aFactory.getClass().getInterfaces(), new daigou(aFactory));
```
Proxy.newProxyInstance()方法就能创造一个动态代理对象

传入参数：
- 传入被代理类的类加载器，传入这个是为了让代理类和被代理类在同一个类加载器中；
- 传入被代理类所继承的接口（可多个），因为动态代理嘛，需要共同去实现同一个接口，用被代理类的getInterfaces()方法即可；
- 传入InvocationHandler的实现类对象，增强行为具体的代码在这个里面，要靠这个对象对被代理类进行增强呀，当然要传它

返回值：
已经成功代理目标类的代理类对象（Proxy），可强转成被代理类的父接口类型（因为代理类这个时候也已经继承了这个父接口类型，所以当然可以用这个接口去接这个对象了）。

想一想静态代理的总结，就能理解为什么要这样创建并使用动态代理了。