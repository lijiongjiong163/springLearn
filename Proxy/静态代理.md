# 实例

我们将创建一个 *Image* 接口和实现了 *Image* 接口的实体类。*ProxyImage* 是一个代理类，减少 *RealImage* 对象加载的内存占用。

*ProxyPatternDemo*，我们的演示类使用 *ProxyImage* 来获取要加载的 *Image* 对象，并按照需求进行显示。

![代理模式的 UML 图](assets/proxy_pattern_uml_diagram.jpg)

那如果我又想用这一个代理类去代理文件，那就得用代理类再去实现File接口，然后再代理类里假如RealFile对象，实现File的方法，这个做法**违反开闭原则**，带来如下问题：

1.可扩展性差

每次有新需求的时候都要改一遍代理类，最后就一大堆在里面

2.可维护性差
假如代理接口有修改（方法名，参数类型什么的），直接导致被代理类和代理类都报错，耦合太高

# 重点
通过这个例子可以看出：代理的几个要素：
- 1.代理类和被代理类必须都实现同一个接口，对吧，这样才能把两个类尽量的规范，拥有同样的行为
- 2.代理类得拿到被代理类得对象吧，它要用自己的方法操作被代理类的同名方法呀,相当于都重写（实现）了一个接口的同一个方法
- 3.如果只是在代理类的方法中调用了被代理类的方法，相当于没代理，所以代理类在调用被代理类的同名方法的时候一定会有所增强

总结一下：
- 1.实现共同接口
- 2.代理类中要有被代理类的对象
- 3.增强行为

